Java Live Study
===
## 2주차 과제
---

### 학습 목록
1. 프리미티브 타입 종류와 값의 범위 그리고 기본 값
2. 프리미티브 타입과 레퍼런스 타입
3. 리터럴
4. 변수 선언 및 초기화하는 방법
5. 변수의 스코프와 라이프타임
6. 타입 변환, 캐스팅 그리고 타입 프로모션
7. 1차 및 2차 배열 선언하기
8. 타입 추론, var


---

### 1번

* 프리미티브 타입 종류와 값의 범위 그리고 기본 값

    * 프리미티브 타입 (기본형 Data type)은 실제의 값(DATA)을 변수에 직접 저장한다.

    * 프리미티브 타입에 값이 할당 되면 memory 구조 중 stack 영역에 올라간다.

    * 프리미티브 타입의 종류, Data크기, 값의 범위
        | 종류 | 변수명 | 크기 | 범위 |
        | :--: | :--: | :--: | :--: |
        | 논리형 | Boolena | 1byte | false, true |
        | 문자형 | char | 2byte | '\u0000' ~ '\uffff' (0~2^16 -1, 0 ~ 65535) |
        | 정수형 | byte | 1byte | -128 ~ 127 (-2^7 ~ 2^7-1) |
        | 정수형 | short | 2byte | -32,768 ~ 32,797 (-2^15 ~ 2^15-1) |
        | 정수형 | int | 4byte | -2,147,483,648 ~ 2,147,483,647 (-2^31 ~2^31-1) |
        | 정수형 | long | 8byte | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 (-2^63 ~ 2^63-1) |
        | 실수형 | float | 4byte | 1.4E-45 ~ 3.4E38 (1.4 x 10^-45 ~ 3.4x10^38) |
        | 실수형 | long | 8byte | 4.9E-324 ~ 1.8E308 (4.9x10^-324 ~ 1.8x10^308 |)

---

### 2번

* 프리미티브 타입과 레퍼런스 타입

    * 레퍼런스 타입(참조형 Data type)은 어떠한 값이 저장되어 있는 주소(memory address)를 값으로 갖는다.

    * 레퍼런스 타입의 종류는 8개의 프리미티브 타입을 제외한 나머지 Data type이다.

    * 레퍼런스 타입의 변수는 memory 구조에서 heap에 올라간다.

    * code로 확인해보자
        ```java
        public class temp {

            int i = 0; //Instance 변수
            int j = 0;

            public temp(){

            }
        
            public static void main(String[]args){

               temp tp = new temp(); //tp가 생성되면 stack에 Instance변수의 시작주소를 가지고 올라감
            }//main

        }//class
        ```
        >참조형 변수 class를 Instance화 시키면 heap 영역에 Instance 변수인 i가 올라가고<br>
        stack 영역에 Instance인 tp가 Instnace 변수 시작주소를 가지고 올라간다.

---

### 3번

* 리터럴

    * 프로그래밍에서 상수를 '값을 한번 저장하면 변경할 수 없는 저장공간'으로 정의하였기 때문에 이와 구분하기 위해 상수를 다른 이름으로 불러야만 했다. 그래서 상수 대신 리터럴이라는 용어를 사용한다.<br>
    (리터럴은 단지 상수의 다른 이름일 뿐이다.)
        >-변수 = 하나의 값을 저장하기 위한 공간<br>
        -상수 = 값을 한번만 저장할 수 있는 공간 (리터럴에 이름만 붙여 코드의 이해를 증가)<br>
        -리터럴 = 그 자체로 값을 의미하는 것
    
        ```java
        int year = 2020; //year = 변수, 2020 = 리터럴
        final int MAX_VALUE = 9999; //MAX_VALUE = 상수
        ```

    * 리터럴의 타입
        
        * 변수의 타입이 있는 것 처럼 리터럴에도 타입이 있다.
        * 변수의 타입은 저장될 '값'의 타입(리터럴의 타입)에 의해 결정된다.
             종류 | 리터럴 | 접미사
             :---: | :---: | :---:
            논리형 | false,true | 없음
            정수형 | 123, 0b0101(8진수), 077, 0xFF(16진수), 100L | L(long type일때) /접미사가 없을시 int type 리터럴
            실수형 |3.14, 3.0e8, 1.4f,0x1.0p-1 |f(float), d(double)-생략가능
            문자형 | 'A', '1', '\n' | 없음
            문자열 | "ABC", "123" | 없음

            >정수형의 기본 리터럴 = int , 실수형의 기본 리터럴은 double

---

### 4번

* 변수 선언 및 초기화하는 방법
    * 변수의 선언은 데이터를 저장할 공간을 확보하겠다는 의미이다.
    ```java
    int temp;
    ```
    > 변수가 선언되면 int형의 Data크기인 4byte를 확보한 것이며 그 공간의 이름은 temp이다.

    * 변수의 초기화는 생성된 저장공간에 데이터를 넣는다는 의미이다.<br>
    (변수를 선언하고 초기화를 하지 않으면 확보된 공간에 알수없는 값이 들어 있으며 사용하지 못한다.)
    ```java
    temp = 1119;
    ```
    > 변수가 선언되면서 확보한 4byte안에 1119라는 값을 넣어주면서 초기화가 된다.

    * 선언과 초기화는 한번에 가능하다.
    ```java
    int temp = 1119;
    ```

---

### 5번 
* 변수의 스코프와 라이프타임

    * 변수의 종류는 선언되는 위치에 따라 3가지로 구분된다.

        변수의 종류 | 선언 위치 | 생성시기
        :---: | :---: | :---:
        클래스 변수(class variable) | 클래스 영역 | 클래스가 메모리에 올라갈 때
        인스턴스 변수(Instance variable)|클래스 영역 | 인스턴스가 생성될 때
        지역 변수(local variable) | 클래스 영역 이외의 영역 (메소드 ,생성자 등등..)|변수 선언문이 수행되었을때

    1. 클래스 변수
        * 클래스 변수의 선언방법
            ```java
            public class temp{
            static int i; //클래스 영역 안에서 변수 앞에 static을 붙여 선언
            }
            ```
        * 클래스 변수는 모든 인스턴스가 공통된 저장공간을 공유하게 된다.
        * 클래스 변수는 클래스가 메모리에 로딩될 때 생성되어 프로그램이 종료될 때 까지 유지된다.
        * 사용 범위는 선언된 class 어디서든 사용이 가능하다.<br>
        (접근지정자에 public을 붙이면 같은 프로그램 내에 어디서든 사용이 가능하다.)

    2. 인스턴스 변수
        * 인스턴스 변수의 선언방법
        ```java
        public class tmep{
            int i;
        }
        ```
        * 인스턴스 변수는 클래스 영역에서 선언되며 클래스가 Instnace화가 될 때 생성된다.
        * 사용 범위는 class내 Static 영역 밖에서 사용이 가능하다.
        * 같은 class로 여러개의 인스턴스를 만들었을 때 인스턴스마다 변수의 값을 다르게 설정 가능.

    3. 지역변수
        * 지역변수의 선언 방법
        ```java
        public static void main(String[]args){
            int i = 0;
        }
        ```
        * 메서드 안에서 선언되며 지역변수는 초기화를 하여 사용해야한다.
        * 사용 범위는 메서드 내에서 사용이 가능하다.
        * 만약 반복문 (for,while)안에서 선언된 지역변수는 반복문이 끝나면 소멸된다.

---

### 6번

* 타입 변환, 캐스팅 그리고 타입 프로모션

    * 타입변환 (Casting)
        * 변수나 리터럴의 타입을 다른 타입으로 변환하는 것을 의미 한다.
            > 프로그램을 작성하다보면 다른 타입들 끼리 연산해야 하는 경우가 생길 때 사용한다.

    * Casting 방법
        * 문법은 (타입)피연산자이다.
            > 괄호 안에 타입을 형 변환 연산자 라고 한다.
        * ex)
        ```java
        double d = 85.4;
        int score = (int)d; // 여기서 int는 형변환 연산자이다.
        ```
        * **`실수형 Data type을 정수형으로 변환하면 소수점 이하 자리는 Data의 손실이 올 수도 있다`**

        * 기본형 Data type은 boolean을 제외한 나머지 타입들은 서로 형 변환이 가능하다.
            변환 | 수식 | 결과
            :--: | :--: | :--:
            int ->  char | (char)65 | 'A'
            char -> int | (int)'A' | 65
            float -> int | (int)1.6f | 1
            int -> float | (float)10 | 10.0f

    * 자동 형변환
        * 서로 다른 타입간의 대입이나 연산을 할 때, 형변환으로 타입을 일치시키는 것이 원칙이다.
        * 경우에 따라 편의상의 이유로 형변환을 생략할 수 있다.
            ```java
            float f = 1234; // 컴파일러가 float f = (float)1234;로 자동추가하여 준다.
        * 자동 형 변환의 규칙
            > 기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환한다.
        
        * 형변환의 흐름
            >byte(1byte) -> short(2byte) -> int(4byte) -> long(8byte) -> float(4byte) -> double(8byte)
    
    * 형변환 정리
        1. boolean을 제외한 기본형 7가지는 서로 형변환이 가능하다.
        2. 기본형과 참조형은 서로 형 변환이 불가능하다.
        3. 서로 다른 타입의 변수간의 연산은 형 변환하는 것이 원칙이지만 작은타입에서 큰타입의 형변환은 생략가능.

---

### 7번

* 1차 및 2차 배열 선언하기

    * 배열( 같은 타입의 여러 변수를 하나의 묶음으로 다루는 것을 의미한다.)

    * 배열의 사용 목적
        * 같은 타입의 여러 변수를 묶어서 일괄 처리 하기 위해서 있다.
        * 같은 타입의 여러 변수들을 Index를 이용해 관리하기 편하게 하기 위해서이다.

    * **`배열의 길이를 한번 설정하면 바꿀수 없다(고정길이형)`**
        >바꿀수 있는 방법은 더 큰 배열을 생성하고 큰 배열에 복사하여 옮긴다.

    * 배열의 생성 (2가지 방법)
        선언방법 | 선언 예
        :---: | :---:
        타입[] 배열의이름 | int[] arr ;
        타입 배열의이름[] | int arr[];

        > memory는 stack에 arr이 올라간다 아직 heap의 주소를 가지고 있지 않다.

    * 1차원 배열의 생성
        ```java
        int[] arr; //배열의 선언
        arr = new int[배열의 길이];
        ```
        > 배열을 생성하면 배열의 값들이 heap에 올라가고 stack에 arr이가 heap에 올라간 Data의 시작주소를 갖는다.<br> (`객체를 만드는 new를 이용해야 heap에 올라간다.`)

        * 배열의 선언과 생성을 같이 할 수 있다.
        ```java
        int[] arr = new int[배열의 길이];
        ```

    * 배열의 초기화
        
        * 배열은 생성과 동시에 정해진 DataType의 초기화 값으로 설정된다.
            데이터 타입 | 초기화 값
            :---: | :---:
            정수형 | 0
            실수형 | 0.0
            참조형 | null

        * 값을 넣어 초기화도 가능하다.
        ```java
        int[] arr = new int[]{0,1,2,3,4};
        ```
        >지금과 같은 겨우에는 (new int[])가 생략가능하다.  

    * 2차원 배열의 선언 및 생성

        * 1차원 배열의 선언 및 생성과 크게 다르지 않다.
        * 2차원 배열은 행과 열을 가지고 index를 관리한다.
        ```java
        int[][] arr = new int[행][열]
        
        int[][] arr = new int[][]{{0,1,2},{4,5,6}};
        ```

---

### 8번 

* 타입 추론, var

    * 타입추론
        * 타입 추론이란 데이터 타입을 소스코드에 명시하지 않아도, 컴파일 단계에서 컴파일러가 타입을 유추해 정해주는 것을 뜻한다.
    
        * 1.5버전 부터 추가된 Generic 이나 자바 8 버전에서 추가된 lamda 에서 타입추론이 사용된다. 그리고 자바 10 에서는 이러한 타입추론을 사용하는 var 이라는 Local Variable Type-Inference 가 추가되었다.

    * var

        * Java 10부터 추가된 특징중 하나인 Local Variable Type Inference은 로컬 변수 선언을 var를 이용하여 기존의 엄격한 타입 선언방식에서 컴파일러에게 타입추론 책임을 위임할 수 있게 되었다.
        ```java
        var i = 10; //int
        var name = "lee" //string
        ```
